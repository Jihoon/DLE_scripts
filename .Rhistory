undebug(commitResults)
ok = nrow(hh) == length(unique(hh$id))
if (!ok) {
message("STOP!!! Number of unique household ID's does NOT match number of HH records!!!")
} else {
commitResults(survey.code)
}
debugSource('P:/ene.general/DecentLivingEnergy/Surveys/Scripts/Functions for building Oracle DB tables.R', echo=TRUE)
ok = nrow(hh) == length(unique(hh$id))
if (!ok) {
message("STOP!!! Number of unique household ID's does NOT match number of HH records!!!")
} else {
commitResults(survey.code)
}
ok = nrow(hh) == length(unique(hh$id))
if (!ok) {
message("STOP!!! Number of unique household ID's does NOT match number of HH records!!!")
} else {
commitResults(survey.code)
}
ok = nrow(hh) == length(unique(hh$id))
if (!ok) {
message("STOP!!! Number of unique household ID's does NOT match number of HH records!!!")
} else {
commitResults(survey.code)
}
row.names
!is.null(row.names(value)
)
F
FALSE
ok = nrow(hh) == length(unique(hh$id))
if (!ok) {
message("STOP!!! Number of unique household ID's does NOT match number of HH records!!!")
} else {
commitResults(survey.code)
}
oNam
oNam
ns
envir
mode
row.names
row.names
name
value
row.names
row.names
row.names=row.names
row.names
f
F
survey.code
ok = nrow(hh) == length(unique(hh$id))
if (!ok) {
message("STOP!!! Number of unique household ID's does NOT match number of HH records!!!")
} else {
commitResults(survey.code)
}
source('P:/ene.general/DecentLivingEnergy/Surveys/Scripts/Functions for building Oracle DB tables.R', echo=TRUE)
ok = nrow(hh) == length(unique(hh$id))
if (!ok) {
message("STOP!!! Number of unique household ID's does NOT match number of HH records!!!")
} else {
commitResults(survey.code)
}
rm()
rm(F)
gc()
rm(
)
rm(T)
# Final safety check before writing to disk and database (ensure unique household ID's)
ok = nrow(hh) == length(unique(hh$id))
if (!ok) {
message("STOP!!! Number of unique household ID's does NOT match number of HH records!!!")
} else {
commitResults(survey.code)
}
debugSource('P:/ene.general/DecentLivingEnergy/Surveys/Scripts/Functions for building Oracle DB tables.R', echo=TRUE)
# Final safety check before writing to disk and database (ensure unique household ID's)
ok = nrow(hh) == length(unique(hh$id))
if (!ok) {
message("STOP!!! Number of unique household ID's does NOT match number of HH records!!!")
} else {
commitResults(survey.code)
}
head(df)
names(df)
table.name
which(names(df)
names(df)
bad.vars
length(bad.vars)>0
?strsplit
strsplit(oracle.reserved.words, ", ")
bad.vars = which(names(df) %in% strsplit(oracle.reserved.words, ", "))
bad.vars
table.name
sql.call
sql.call
dbSendUpdate(conn, sql.call)
dim(othcon)
dim(unique(othcon))
table.name
paste0("ALTER TABLE ",table.name,"\nADD CONSTRAINT ",paste0(table.name,"_PK")," PRIMARY KEY (",paste0(names(df)[pid], collapse=","),")")
pid
primary.keys
head(othcon)
dim(unique(othcon[,1:3]))
dim((othcon[,1:3]))
str(othcon)
dim((othcon[,1:2]))
dim((othcon))
dim(unique(othcon[,1:2]))
setdiff(othcon[,1:2], unique(othcon[,1:2]))
comparison <- compare(othcon[,1:2],unique(othcon[,1:2]),allowAll=TRUE)
comparison$tM
library(compare)
comparison <- compare(othcon[,1:2],unique(othcon[,1:2]),allowAll=TRUE)
comparison$tM
difference <-
data.frame(lapply(1:ncol(othcon[,1:2]),function(i)setdiff(othcon[,1:2][,i],comparison$tM[,i])))
colnames(difference) <- colnames(othcon[,1:2])
difference
str(comparison$tM)
difference <-
data.frame(lapply(1:ncol(othcon[,1:2]),function(i)setdiff(othcon[,1:2][,i],comparison$tM[[i]])))
# Final safety check before writing to disk and database (ensure unique household ID's)
ok = nrow(hh) == length(unique(hh$id))
if (!ok) {
message("STOP!!! Number of unique household ID's does NOT match number of HH records!!!")
} else {
commitResults(survey.code)
}dim(unique(othcon[,1:2]))
dim(unique(othcon[,1:2]))
dim((othcon[,1:2]))
othcon = cons %>%
filter(type=="Other consumption") %>%
mutate_if(str_split_fixed(item, ";", 2)[,2]==" free", value_free=value) %>%
mutate(item = str_split_fixed(item, ";", 2)[,1]) %>%
group_by(id, item, code) %>%
summarize(val_tot=sum(value), val_free=sum(value_free, na.rm=T))
head(d)
grep("Candles", othcon$item)
grep("candles", othcon$item)
?grep
grep("candles", othcon$item, ignore.case = TRUE)
head(othcon)
grep("phone", othcon$item, ignore.case = TRUE)
grep("fuel", othcon$item, ignore.case = TRUE)
othcon$item[grep("fuel", othcon$item, ignore.case = TRUE)]
dim(unique(othcon[,1:2]))
dim(unique(othcon))
dim(cons %>%
filter(type=="Other consumption") )
temp <- cons %>%
filter(type=="Other consumption") %>%
mutate_if(str_split_fixed(item, ";", 2)[,2]==" free", value_free=value) %>%
mutate(item = str_split_fixed(item, ";", 2)[,1]) %>%
group_by(id, item) %>% summarise(count = n())
temp <- cons %>%
filter(type=="Other consumption") %>%
mutate_if(str_split_fixed(item, ";", 2)[,2]==" free", value_free=value) %>%
mutate(item = str_split_fixed(item, ";", 2)[,1]) %>%
group_by(id, item) %>% summarise(count = n()) %>% filter(count>1)
temp
temp <- cons %>%
filter(type=="Other consumption") %>%
mutate_if(str_split_fixed(item, ";", 2)[,2]==" free", value_free=value) %>%
mutate(item = str_split_fixed(item, ";", 2)[,1]) %>%
group_by(id, item) %>% summarise(count = n()) %>% filter(count>2)
temp
head(cons)
temp <- cons %>%
group_by(id, item) %>% summarise(count = n()) %>% filter(count>1)
temp
temp <- cons %>%
group_by(id, item) %>% summarise(count = n()) %>% filter(count>1) %>% arrange(id, item)
temp
?arrange
temp <- cons %>%
group_by(id, item) %>% summarise(count = n()) %>% filter(count>1) %>% arrange(id)
temp
temp <- cons %>%
filter(type=="Other consumption") %>%
mutate_if(str_split_fixed(item, ";", 2)[,2]==" free", value_free=value) %>%
mutate(item = str_split_fixed(item, ";", 2)[,1]) %>%
group_by(id, item) %>% summarise(count = n()) %>% filter(count>1)
temp
View(temp)
?n
temp <- cons %>%
filter(type=="Other consumption") %>%
group_by(id, item) %>% summarise(count = n()) %>% filter(count>1)
temp <- cons %>%
filter(type=="Other consumption") %>%
mutate(item = str_split_fixed(item, ";", 2)[,1]) %>%
group_by(id, item) %>% summarise(count = n()) %>% filter(count>1)
temp <- cons %>%
mutate(item = str_split_fixed(item, ";", 2)[,1]) %>%
group_by(id, item)
temp <- cons %>%
filter(type=="Other consumption") %>%
group_by(id, item)
temp <- cons %>%
filter(type=="Other consumption") %>%
mutate_if(str_split_fixed(item, ";", 2)[,2]==" free", value_free=value) %>%
mutate(item = str_split_fixed(item, ";", 2)[,1]) %>%
group_by(id, item, code)
othcon = cons %>%
filter(type=="Other consumption") %>%
mutate_if(str_split_fixed(item, ";", 2)[,2]==" free", value_free=value) %>%
mutate(item = str_split_fixed(item, ";", 2)[,1]) %>%
group_by(id, item, code) %>%
summarize(val_tot=sum(value), val_free=sum(value_free, na.rm=T))
View(othcon)
saveSurvey2Disk(othcon, keys=c('id','item'), id.vals=hh$id)
commitSurvey2DB(othcon, keys=c('id','item'))
commitResults(survey.code)
keys
survey.code
keys
source('P:/ene.general/DecentLivingEnergy/Surveys/Generic function to access database.R', echo=TRUE)
?trim
?strsplit
commitSurvey2DB(othcon, keys=c('id','item', 'code'))
commitSurvey2DB(asset, keys=c('id','item'))
Sys.time() - start
scode
grepl("IND|ZAF", "ZAF1"))
grepl("IND|ZAF", "ZAF1")
grepl("IND|ZAF", "IND1")
source('P:/ene.general/DecentLivingEnergy/Surveys/Scripts/Functions for building Oracle DB tables.R', echo=TRUE)
ok = nrow(hh) == length(unique(hh$id))
if (!ok) {
message("STOP!!! Number of unique household ID's does NOT match number of HH records!!!")
} else {
commitResults(survey.code)
}
debugSource('P:/ene.general/DecentLivingEnergy/Surveys/Scripts/Functions for building Oracle DB tables.R', echo=TRUE)
ok = nrow(hh) == length(unique(hh$id))
if (!ok) {
message("STOP!!! Number of unique household ID's does NOT match number of HH records!!!")
} else {
commitResults(survey.code)
}
source('P:/ene.general/DecentLivingEnergy/Surveys/South Africa/IES 2010-2011/Processed/01 ZAF IES 2010-2011 Data processing script - fuel updated.R', echo=TRUE)
load("Data/ies_2010_2011_person_info_v1.rdata")
d = person_info %>%
rename(id=uqno, pid=personno, weight=Full_calwgt, age=Q14AGE) %>%
genvar(male, Q12SEX, c(1,0), c(1,2)) %>%
genvar(rel, Q15RELATIONSHIP, c('Head', 'Husband/wife/partner', 'Son/daughter/stepchild/adopted child', 'Father/mother', 'Grandparent/Great-grandparent', 'Other relative', 'Live-in domestic worker', 'Other non-related person', 'Temporary visitor'), 1:9) %>%
genvar(head, Q15RELATIONSHIP, T, 1, other=FALSE) %>%
genvar(race, Q13POPGROUP, c("African/Black", "Coloured", "Indian/Asian", "White"), 1:4) %>%
genvar(educ_level, Q21HIGHESTLEVEL, c('Grade 0','Grade 1','Grade 2','Grade 3/Standard 1/ABET 1','Grade 4/Standard 2','Grade 5/Standard 3/ABET 2','Grade 6/Standard 4','Grade 7/Standard 5/ABET 3','Grade 8/Standard 5/ABET 3','Grade 9/Standard 7/ABET 4','Grade 10/Standard 8/NTC I','Grade 11/Standard 9/NTC II','Attended but not completed Grade 12','Grade 12/Standard 10/NTC III (no univ. exemption)','Grade 12/Standard 10/NTC III (with univ. exemption)','Certificate with less than Grade 12/Standard 10','Diploma with less than Grade 12/Standard 10','Certificate with Grade 12/Standard 10','Diploma with Grade 12/Standard 10','Bachelors degree 3 years','Bachelors degree 4 years or more','Postgraduate diploma','Honours degree','No schooling','Out of scope (less than 5 years of age)',NA,NA), c(0:22,24:27)) %>%
genvar(student, Q22ATTEND, c(1,0), c(1,2)) %>%
genvar(wages, Q1601SALARY, T, 1, other=FALSE) %>%
genvar(businc, Q1602NETPROFIT, T, 1, other=FALSE) %>%
genvar(farminc, Q1603SUBSFARM, T, 1, other=FALSE) %>%
mutate_if(educ_level=="Out of scope (less than 5 years of age)" & age>=5, educ=NA) %>%  # Erroneous education value
mutate_if(educ_level=="Out of scope (less than 5 years of age)", student=0) %>%
mutate_if(age<5 & !educ_level %in% c("Out of scope (less than 5 years of age)", "No schooling"), age=NA) %>%  # Erroneous age value
mutate_if(age<5, educ_level="Out of scope (less than 5 years of age)") %>%  # Erroneous age value
left_join(educ_years) %>% # Add years of schooling completed
select(id, pid, weight, rel, head, male, age, race, educ_level, educ_years, student, wages, businc, farminc) %>%
data.table
# Ensure that if household size is one, the lone individual is specified as the household head
# Also ensure that if no household head is specified, status is assigned to oldest individual (male if tiebreak required)
d = d %>%
left_join(d[,list(n = .N, h = sum(head, na.rm=T)), by=id]) %>%
mutate_if(n==1, head=T, h=1)
heads = d %>%
filter(h==0) %>%
arrange(id, -age, -male) %>%
unique(by="id") %>%
mutate(head=T, rel='Head')
d = d %>%
anti_join(select(heads,id,pid)) %>%
rbind(heads) %>%
select(-n, -h)
# Impute missing age values in person record data; complete age variable needed to create summary variables below
# Do not impute non-age variables here (e.g. education); they are imputed later on at household level
if (any(is.na(d$age))) {
d = imputeDataset(d, weight="weight", skip=setdiff(names(d), "age"), exclude=c("id","pid"), depth=4)
}
# Create household summary variables from person records
pp = d[,list(
hh_size = .N,
male = male[head],
age = age[head],
race = race[head],
educ_level = educ_level[head],
educ_years = educ_years[head],
minor = sum(age<18), # Number of minors (less than 18 years old)
student = sum(student),
worker = sum(wages | businc | farminc), # Number of workers (either wages, business income, or income from subsistence farming)
domestic = as.integer(any(rel=='Live-in domestic worker')),  # Presence of live-in domestic worker(s)
male_adult = sum(age>=18 & male==1),
male_minor = sum(age<18 & male==1),
age_adult = mean(age[age>=18]),  # Mean age of people over 18 (can be NA in case of minor head of household)
age_minor = mean(age[age<18])  # Mean age of people under 18 (will be NA if no minors in household)
), by=id]
# If multiple household heads specified, retain information for eldest head only (male if age is a tie)
#check = pp[,list(n = .N), by=id] %>% filter(n>1)
pp = pp %>%
arrange(id, -age, -male) %>%
unique(by="id")
#---------------
#---------------
# Combine household level variables
hh = Reduce(function(...) left_join(...), list(hh,pp))
#---------------
#---------------
# Create household asset data frame
load("Data/ies_2010_2011_house_info_v1.rdata")
asset.var = c('Q5101A01RADIO', 'Q5101A02STEREO', 'Q5101A03TELEVISION', 'Q5101A04DVDPLAYER', 'Q5101A05REFRIGERATOR', 'Q5101A06STOVE', 'Q5101A07MICROWAVE', 'Q5101A08WASHINGMACHINE', 'Q5101A09MOTORVEHICLE', 'Q5101A10MOTORCYCLE', 'Q5101A11COMPUTER', 'Q5101A12GENERATOR', 'Q5101A13CAMERA', 'Q5101A14CELLULARPHONE', 'Q5101A15LANDLINEPHONE', 'Q5101A16DSTV', 'Q5101A17INTERNET', 'Q5101A18POWERTOOLS', 'Q5101A19KITCHENFURNITURE', 'Q5101A20DININGFURNITURE', 'Q5101A21LOUNGEFURNITURE', 'Q5101A22BEDROOMFURNITURE')
asset.item = c('Radio', 'Stereo/HiFi', 'Television', 'DVD player', 'Refrigerator/freezer', 'Stove (gas, electric, or paraffin)', 'Microwave oven', 'Washing machine', 'Motor vehicle', 'Motorcycle/scooter', 'Computer', 'Generator', 'Camera', 'Cellphone', 'Landline telephone', 'DStv', 'Internet service', 'Power driven tool(s) (e.g. electric drill)', 'Kitchen furniture', 'Dining room furniture', 'Lounge furniture','Bedroom furniture')
asset = house_info %>%
rename(id=uqno) %>%
select_(.dots=c('id',asset.var) %>% unname) %>%
setnames(asset.var, asset.item) %>%
gather(item, value, -id, convert=T) %>%  # 'convert' option necessary to keep 'item' as character
genvar(pos, value, c(1,0), c(1,2)) %>%
select(-value) %>%
filter(pos!=0 | is.na(pos)) %>%  # Eliminate zero values (but retain legitimate NA's)
select(id, item, everything())
#---------------
#---------------
# Process detailed consumption data
load("Data/ies_2010_2011_total_v1.rdata")
d = total_ies
names(d) =  tolower(names(d))
# List items to be assigned as FUEL items
# NOTE: This list should only contain the text before semi-colon in full fuel item name
# fuel.items = c("LPG", "Gasoline/diesel", "Water and Electricity", "Electricity", "Firewood", "Charcoal", "Gasoline", "Kerosene", "Natural gas", "Coal", "Diesel", "Dung")
fuel.items = c("LPG", "Gasoline/diesel", "Water and Electricity", "Electricity", "Firewood", "Charcoal", "Gasoline", "Kerosene", "Natural gas", "Coal", "Diesel", "Dung", "Candles", "Other household fuel", "Crop residue")  # Updated by J.Min 04/12/2017
# Extract necessary variables (few explicit zero values in this data but retained if available)
cons = d %>%
select(-value) %>%
rename(id=uqno, value=valueannualized) %>%
mutate(code = str_pad(coicop, width=8, pad=0)) %>%
genvar(class, coicoptype, c('Consumption', 'In kind consumption', 'Income', 'In kind income', 'Savings', 'Taxes', 'Transfers to others', 'Debts', 'Other products not in consumption'), c(1:8,10)) %>%
genvar(area_of_purchase, aop, c('Big city (e.g. metro)', 'Other urban area (town/township)', 'Rural/traditional area', 'Not applicable', 'Do not know'), 1:5) %>%
genvar(type_of_retailer, tor, c('Chain store', 'Internet', 'Other retailer', 'Street trading', 'Other', 'Not applicable', 'Do not know'), 1:7) %>%
data.table(key=c('code')) %>%
merge(ce_code) %>%
mutate_if(str_sub(code,1,2) %in% c('01','02') | str_sub(code,1,3) %in% c('661','662','111'), type="Food") %>%  # Identify food and drink items; NOTE: This includes "food services" items (i.e. restaurant/prepared meals)
mutate_if(str_split_fixed(item, ";", 2)[,1] %in% fuel.items, type="Fuel") %>%  # Flag/identify fuel items)
mutate_if(is.na(type) & class %in% c('Consumption', 'In kind consumption'), type="Other consumption") %>%
select(id, item, code, class, type, value)
# Aggregate (sum) value and quantity columns by ID, item, etc.
# Note: This is primarily a safety check, since it will aggregate across each id-item (item codes are dropped above)
cons = data.table(cons, key=setdiff(names(cons),'value'))
cons = cons[,lapply(.SD, sum), by=key(cons)]
# Adjust value for purchasing power...
# Annualized value extracted above is already inflated/deflated to March 2011 prices in local currency
ppp = readRDS("P:/ene.general/DecentLivingEnergy/Surveys/Consumer Prices/Monthly PPP adjustment factors for base year 2010.RData")
ppp_fact = filter(ppp, iso3=="ZAF", year==2011, month==3)$ppp_fact
cons$value = round(cons$value * ppp_fact, 2)  # Convert 'value' variable to $PPP in base year, rounded to 2 decimal places
#---------------
#---------------
# Extract food items
food = cons %>%
filter(type=="Food", value>0 | is.na(value)) %>%  # Remove any observations where val_tot==0
mutate_if(str_split_fixed(item, ";", 2)[,2]==" own production", value_own=value) %>%
mutate(item = gsub(";", ",", item, fixed=T)) %>%  # This replaces semi-colons with commas in remaining item names (e.g. "Vegetables, own production")
group_by(id, item, code) %>%
summarize(val_tot=sum(value), val_own=sum(value_own, na.rm=T)) %>%
ungroup %>%
filter(val_tot>0 | is.na(val_tot))
# Extract fuel items
# NOTE: fuel includes "Water and Electricity" line item at this point; this item is disaggregated in imputation code below (imputed Water component eventually sent to 'othcon' data frame)
fuel = cons %>%
filter(type=="Fuel") %>%
mutate_if(str_split_fixed(item, ";", 2)[,2]==" collected", value_col=value) %>%
mutate_if(str_split_fixed(item, ";", 2)[,2]==" free", value_free=value) %>%
mutate_if(str_split_fixed(item, ";", 2)[,2]==" prepaid", value_free=0) %>%
mutate_if(str_split_fixed(item, ";", 2)[,2]==" purchased", value_free=0) %>%
mutate(fuel = ifelse(!is.na(value_col) | !is.na(value_free), str_split_fixed(item, ";", 2)[,1], item)) %>%
mutate(fuel = gsub(";", ",", fuel, fixed=T)) %>%  # This replaces semi-colons with commas in remaining fuel names (e.g. "Gasoline/diesel, transport")
group_by(id, fuel) %>%
summarize(val_tot=sum(value), val_col=sum(value_col, na.rm=T), val_free=sum(value_free, na.rm=T))
# Other consumption does NOT include value of free electricity or combined "Water and Electricity" item since both recorded in the 'fuel' object
# NOTE: ALL item names in 'ce_code' with semi-colon will use only portion of string prior to semi-colon (can cause errors when setting DC constraints if behavior is not as expected)
# Treatment of semi-colons in 'ce_code' must be correct; currently, this only affects "Water; free" and "Sanitation; free"
othcon = cons %>%
filter(type=="Other consumption") %>%
mutate_if(str_split_fixed(item, ";", 2)[,2]==" free", value_free=value) %>%
mutate(item = str_split_fixed(item, ";", 2)[,1]) %>%
group_by(id, item, code) %>%
summarize(val_tot=sum(value), val_free=sum(value_free, na.rm=T))
# Income does not include in-kind income OR imputed rent on owned dwelling
income = cons %>%
filter(class=="Income" & item!="Imputed rent on owned dwelling") %>%
group_by(id, item) %>%
summarize(val_tot=sum(value))
#---------------
#---------------
# Split 'Water and Electricity' line item into sepatrate electricity and water components
# The 'Water and Electricity' item occurs when HH is billed for both together and cannot distinguish when reporting
# Since electricity should be part of the FUEL output data frame and water part of OTHCON, it is necessary to "split" this line item
# Code below imputes the share of total 'Water and Electricity' value that is attributable to electricity
# Imputation uses observations with complete (separate) electricity and water values to fit a GBM prediction model
# Once split, the electricity component is correctly assigned to the 'fuel' data frame; water to 'othcon'
WEid = filter(fuel, fuel=="Water and Electricity")$id
fdata = fuel %>%
filter((fuel=="Electricity" & val_tot>0 & !id %in% WEid) | fuel=="Water and Electricity") %>%
rename(item=fuel) %>%
bind_rows(othcon %>%
group_by(id, item) %>%
summarize(val_tot=sum(val_tot), val_free=sum(val_free, na.rm=T)) %>%
filter(item=="Water")) %>%
gather(type, value, val_tot:val_free) %>%
mutate_if(item=="Water and Electricity", item="WE") %>%
filter(type %in% c("val_free","val_col")==FALSE, item %in% c("Electricity","Water") | (item=="WE" & type=="val_tot")) %>%
unite(var, item, type, sep=".") %>%
spread(var, value)
# IMPUTE elec_share: share of combined Water and Electricity consumption that is attributable to electricity
# Note: Could possibly try the huberized hinge loss here... (0-1 continuous)
imp = hh %>%
left_join(fdata) %>%
mutate(WE_flag = ifelse(is.finite(WE.val_tot), 1, 0)) %>%
mutate_if(is.na(WE.val_tot) & is.finite(Electricity.val_tot) & is.finite(Water.val_tot), WE.val_tot=Electricity.val_tot+Water.val_tot) %>%
filter(elec_connect==1, WE_flag==1 | (WE_flag==0 & WE.val_tot>0)) %>%
mutate(elec_share = pmin(Electricity.val_tot/WE.val_tot, 1)) %>%
select(-Electricity.val_tot, -Water.val_tot)
out = imputeDataset(imp, weight="weight", skip=setdiff(names(imp), "elec_share"), exclude=c("id","date_int","elec_connect","WE_flag","elec_consume","elec_access"), depth=4, ncores=1)
out = out %>%
filter(WE_flag==1) %>%
mutate(Electricity.val_tot = WE.val_tot*elec_share, Water.val_tot=WE.val_tot*(1-elec_share)) %>%
select(id, Electricity.val_tot, Water.val_tot) %>%
rename(Electricity=Electricity.val_tot, Water=Water.val_tot) %>%
gather(item, val_tot, -id, convert=T)
# Update fuel data with imputed Electricity values
fuel = fuel %>%
filter(fuel!="Water and Electricity") %>%
bind_rows(filter(out, item=="Electricity") %>% rename(fuel=item)) %>%
group_by(id, fuel) %>%
summarize_each(funs(sum(.,na.rm=T))) %>%
ungroup %>%
filter(val_tot>0 | is.na(val_tot))
# Update othcon data with imputed Water values
# Assign COICPO generic Water item code to relevant observations in 'out'
othcon = othcon %>%
bind_rows(out %>%
filter(item=="Water") %>%
mutate(code="04411010")) %>%
group_by(id, item, code) %>%
summarize_each(funs(sum(.,na.rm=T))) %>%
ungroup %>%
filter(val_tot>0 | is.na(val_tot))
#---------------
#---------------
# Calculate income, consumption, and expenditure totals for each household and add to household summary data
# Total income includes all types in 'income' object
inc_total = income %>%
group_by(id) %>%
summarize(income=sum(val_tot))
# Consumption includes in-kind consumption and imputed rent on owned dwellings...
con_total = bind_rows(food, fuel, othcon) %>%
group_by(id) %>%
summarize(consumption=sum(val_tot))
# Expenditure EXCLUDES own production, free consumption, collected fuel consumption, in-kind consumption (e.g. discounts, grants, etc.), and imputed rent on owned dwellings
# See 'exp.exclude' for list of items exluded from expenditure
exp.exclude = unique(filter(cons, item=="Imputed rent on owned dwelling" | class=="In kind income")$item)
exp_total = bind_rows(food, fuel, othcon) %>%
filter(item %in% exp.exclude==FALSE) %>%
group_by(id) %>%
summarize(expenditure=sum(val_tot,-val_own,-val_col,-val_free, na.rm=T))  # This subtracts own consumption, collected fuel, and free consumption from total consumption
# Add income, consumption, and expenditure totals to HH file
hh = hh %>%
select_("-one_of(c('income','expenditure','consumption'))") %>%
left_join(inc_total) %>%
left_join(con_total) %>%
left_join(exp_total)
#---------------
#---------------
# Construct alternative 'elec_accessX' variables
hh = hh %>%
left_join(fuel %>%
filter(fuel=="Electricity") %>%
mutate(elec_consume=as.integer(val_tot>0)) %>%
select(id, elec_consume)
) %>%
mutate_if(is.na(elec_consume), elec_consume=0) %>%
mutate(elec_access1 = as.integer(elec_connect==1)) %>%
mutate(elec_access2 = as.integer(elec_connect==1 | elec_consume==1))
out = imputeDataset(imp, weight="weight", skip=setdiff(names(imp), "elec_share"), exclude=c("id","date_int","elec_connect","WE_flag","elec_consume","elec_access"), depth=4, ncores=1)
head(imp)
dim(imp)
setdiff(names(imp), "elec_share")
?imputeDataset
out = imputeDataset(imp, weight="weight", skip=setdiff(names(imp), "elec_share"), exclude=c("id","date_int","elec_connect","WE_flag","elec_consume","elec_access"), depth=4, ncores=1)
debugSource('P:/ene.general/DecentLivingEnergy/Surveys/Scripts/Missing data imputation function.R', echo=TRUE)
out = imputeDataset(imp, weight="weight", skip=setdiff(names(imp), "elec_share"), exclude=c("id","date_int","elec_connect","WE_flag","elec_consume","elec_access"), depth=4, ncores=1)
head(vimp)
models = lapply(vimp, fitModel, dset=dset, weights=weights, ntrees=ntrees, depth=depth)
var
dset[ind,var]
dim(dset[ind,var])
dim(dset[ind,xnames])
nrow(y)
length(y)
nrow(x)
class(y)
nrow(y)
debugSource('P:/ene.general/DecentLivingEnergy/Surveys/Scripts/Missing data imputation function.R', echo=TRUE)
out = imputeDataset(imp, weight="weight", skip=setdiff(names(imp), "elec_share"), exclude=c("id","date_int","elec_connect","WE_flag","elec_consume","elec_access"), depth=4, ncores=1)
class(y) == "Surv"
class(y) == "Surv"
class(y)
