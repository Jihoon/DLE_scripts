idx.trp <- as.vector(sapply(seq(0,9400,200), function(x) x+idx_trnsprt_EXIO, simplify = "array"))
direct.int.trp <- totuse_int # totuse_int: Globally defined
direct.int.trp[, -idx.trp] <- 0
# Derive total demand: L*y
ind.x.sect <- eigenMapMatMult(as.matrix(L_inverse), y.unit)   # 9600x1  the column of L_inv
e.trp <- eigenMapMatMult(direct.int.trp, diag(as.vector(ind.x.sect)))   # n_carrierx9600
e.elec <- eigenMapMatMult(elec_int, diag(as.vector(ind.x.sect)))   # elec_int: Globally defined
energy.i.elec <- function(i) {
idx <- as.vector(sapply(seq(0,9400,200), function(x) x+i, simplify = "array"))
return(sum(e.elec[, idx]))
}
energy.i <- function(i) {
return(sum(e.trp[, i+seq(0, 9400, 200)]))
}
energy.trp <- sapply(idx_trnsprt_EXIO, energy.i) # Need to sum for each mode
energy.elec <- energy.i.elec(idx_industry_EXIO)  # Need just the sum of all
energy.therm <- TFEI.tot[cty_idx[exio.sect.idx]] - energy.elec - sum(energy.trp)
industry_trp_energy <- c(energy.therm, energy.elec, energy.trp) # Total indirect energy/cap by decile
# not_conv_idx has 1 where the RAS did not converge.
# industry_trp_energy <- industry_trp_energy[not_conv_idx!=1,]
names(industry_trp_energy) <- c("Industry.themal", "Industry.elec", EX_catnames[idx_trnsprt_EXIO])
return(industry_trp_energy)
}
a.ex <- sapply(c(1:200), function(x) {
DeriveConsumptionEnergyShares.ex("IN", x, type='final')})
map.EXIO.IEA
map.EXIO.IEA$IEA.sect=="Energy"
which(map.EXIO.IEA$IEA.sect=="Energy")
energy_sector_idx_ex
view(data.frame(EXIO=t(EX_catnames), t(a.ex), TFEI=TFEI.tot[IND_idx_ex],
DFEI=colSums(f_energy_int)[IND_idx_ex],
TPEI=colSums(indirect_pE_int.elec.prirow)[IND_idx_ex],
DPEI=colSums(p_energy_int.prirow)[IND_idx_ex], TEI=colSums(indirect_El_int)[IND_idx_ex],
DEI=colSums(elec_int)[IND_idx_ex]))
intensity.summary <- data.frame(EXIO=t(EX_catnames), t(a.ex), TFEI=TFEI.tot[IND_idx_ex],
DFEI=colSums(f_energy_int)[IND_idx_ex],
TPEI=colSums(indirect_pE_int.elec.prirow)[IND_idx_ex],
DPEI=colSums(p_energy_int.prirow)[IND_idx_ex], TEI=colSums(indirect_El_int)[IND_idx_ex],
DEI=colSums(elec_int)[IND_idx_ex])
intensity.summary[which(intensity.summary$TFEI==0), c(2:10)] <- 0
view(intensity.summary)
DeriveConsumptionEnergyShares.ex <- function (country = "IN", exio.sect.idx, type='final',
tfei=TFEI.tot, tpei=indirect_pE_int.elec.prirow, elec.share=sc) {
industry_trp_energy <- vector()
idx_trnsprt_EXIO <- 157:163
idx_industry_EXIO <- setdiff(1:200, idx_trnsprt_EXIO)
print(exio.sect.idx)
cty_place <- which(exio_ctys==country)
cty_idx <- seq(200*(cty_place-1)+1, 200*cty_place)  # 200 EXIO commodities per country
# Unit FD vector for the sector i (=exio.sect.idx)
y.unit <- matrix(unit.vector(cty_idx[exio.sect.idx], 9600), ncol=1)
# if(type=='final') {
#   int.e <- totuse_int   # We still need to add direct final energy intensity after this.
# }
# else if(type=='primary') {
#   int.e <- p_energy_int.prirow
# }
# Carve out only the transport sectors
idx.trp <- as.vector(sapply(seq(0,9400,200), function(x) x+idx_trnsprt_EXIO, simplify = "array"))
direct.int.trp <- totuse_int # totuse_int: Globally defined
direct.int.trp[, -idx.trp] <- 0
# Derive total demand: L*y
ind.x.sect <- eigenMapMatMult(as.matrix(L_inverse), y.unit)   # 9600x1  the column of L_inv
### Total transport energy
e.trp <- eigenMapMatMult(direct.int.trp, diag(as.vector(ind.x.sect)))   # n_carrierx9600
energy.i <- function(i) {
return(sum(e.trp[, i+seq(0, 9400, 200)]))
}
energy.trp <- sapply(idx_trnsprt_EXIO, energy.i) # Need to sum for each mode
### Total non-transport energy
# Approach 1. Get total elec from EXIO and subtract it (& transport E) from TFEI.tot
# e.elec <- eigenMapMatMult(elec_int, diag(as.vector(ind.x.sect)))   # elec_int: Globally defined
#
# energy.i.elec <- function(i) {
#   idx <- as.vector(sapply(seq(0,9400,200), function(x) x+i, simplify = "array"))
#   return(sum(e.elec[, idx]))
# }
# energy.elec <- energy.i.elec(idx_industry_EXIO)  # Need just the sum of all
# energy.therm <- TFEI.tot[cty_idx[exio.sect.idx]] - energy.elec - sum(energy.trp)
# Approach 2. Ignore total elec from EXIO and just scale total with sc
# With an assumption that sc is same for dfei and tfei
energy.nontrp <- TFEI.tot[cty_idx[exio.sect.idx]] - sum(energy.trp)
energy.elec <- energy.nontrp * sc[cty_idx[exio.sect.idx]]
energy.therm <- energy.nontrp * (1-sc[cty_idx[exio.sect.idx]])
industry_trp_energy <- c(energy.therm, energy.elec, energy.trp) # Total indirect energy/cap by decile
# not_conv_idx has 1 where the RAS did not converge.
# industry_trp_energy <- industry_trp_energy[not_conv_idx!=1,]
names(industry_trp_energy) <- c("Industry.themal", "Industry.elec", EX_catnames[idx_trnsprt_EXIO])
return(industry_trp_energy)
}
sc <- rep(scaler.P.F$Oth$elec.share, 48); sc[BRA_idx_ex] <- scaler.P.F$BRA$elec.share; sc[IND_idx_ex] <- scaler.P.F$IND$elec.share; sc[ZAF_idx_ex] <- scaler.P.F$ZAF$elec.share
a.ex2 <- sapply(c(1:2), function(x) {
DeriveConsumptionEnergyShares.ex("IN", x, type='final')})
a.ex2
a.ex2 <- sapply(c(1:200), function(x) {
DeriveConsumptionEnergyShares.ex("IN", x, type='final')})
intensity.summary2 <- data.frame(EXIO=t(EX_catnames), t(a.ex2), TFEI=TFEI.tot[IND_idx_ex],
DFEI=colSums(f_energy_int)[IND_idx_ex],
TPEI=colSums(indirect_pE_int.elec.prirow)[IND_idx_ex],
DPEI=colSums(p_energy_int.prirow)[IND_idx_ex], TEI=colSums(indirect_El_int)[IND_idx_ex],
DEI=colSums(elec_int)[IND_idx_ex])
intensity.summary2[which(intensity.summary2$TFEI==0), c(2:10)] <- 0
view(intensity.summary2)
(f_energy_int)[IND_idx_ex]
view((f_energy_int)[IND_idx_ex])
view((f_energy_int)[,IND_idx_ex])
colSums(p_energy_int.prirow)[IND_idx_ex]
EX_catnames
view(sapply(157:163, function(x) {rowSums(matrix(L_inverse[IND_idx_ex[x]], nrow=200))}))
view(sapply(c(157:163), function(x) {rowSums(matrix(L_inverse[IND_idx_ex[x]], nrow=200))}))
rowSums(matrix(L_inverse[IND_idx_ex[157]], nrow=200))
matrix(L_inverse[IND_idx_ex[157]], nrow=200)
view(sapply(c(157:163), function(x) {rowSums(matrix(L_inverse[,IND_idx_ex[x]], nrow=200))}))
EX_catnames[157:163]
a <- data.frame(EXIO=t(EX_catnames), sapply(c(157:163), function(x) {rowSums(matrix(L_inverse[,IND_idx_ex[x]], nrow=200))}))
names(a)[-1] <- EX_catnames[157:163]
view(a)
DeriveConsumptionEnergyShares.ex <- function (country = "IN", exio.sect.idx, type='final',
tfei=TFEI.tot, tpei=indirect_pE_int.elec.prirow, elec.share=sc) {
industry_trp_energy <- vector()
idx_trnsprt_EXIO <- 157:163
idx_industry_EXIO <- setdiff(1:200, idx_trnsprt_EXIO)
print(exio.sect.idx)
cty_place <- which(exio_ctys==country)
cty_idx <- seq(200*(cty_place-1)+1, 200*cty_place)  # 200 EXIO commodities per country
# Unit FD vector for the sector i (=exio.sect.idx)
y.unit <- matrix(unit.vector(cty_idx[exio.sect.idx], 9600), ncol=1)
# if(type=='final') {
#   int.e <- totuse_int   # We still need to add direct final energy intensity after this.
# }
# else if(type=='primary') {
#   int.e <- p_energy_int.prirow
# }
# Carve out only the transport sectors
idx.trp <- as.vector(sapply(seq(0,9400,200), function(x) x+idx_trnsprt_EXIO, simplify = "array"))
direct.int.trp <- totuse_int # totuse_int: Globally defined
direct.int.trp[, -idx.trp] <- 0
# Derive total demand: L*y
ind.x.sect <- eigenMapMatMult(as.matrix(L_inverse), y.unit)   # 9600x1  the column of L_inv
### Total transport energy
e.trp <- eigenMapMatMult(direct.int.trp, diag(as.vector(ind.x.sect)))   # n_carrierx9600
energy.i <- function(i) {
return(sum(e.trp[, i+seq(0, 9400, 200)]))
}
energy.trp <- sapply(idx_trnsprt_EXIO, energy.i) # Need to sum for each mode
# Assumption: Total transport energy is 100% transport energy
# Otherwise, some exceptionally high DFEI transport sector (e.g. inland water in IND) gives (-) intensity for tfei.ind.
if (exio.sect.idx %in% idx_trnsprt_EXIO) {
energy.trp <- energy.trp / sum(energy.trp) * TFEI.tot[cty_idx[exio.sect.idx]]
}
### Total non-transport energy
# Approach 1. Get total elec from EXIO and subtract it (& transport E) from TFEI.tot
# e.elec <- eigenMapMatMult(elec_int, diag(as.vector(ind.x.sect)))   # elec_int: Globally defined
#
# energy.i.elec <- function(i) {
#   idx <- as.vector(sapply(seq(0,9400,200), function(x) x+i, simplify = "array"))
#   return(sum(e.elec[, idx]))
# }
# energy.elec <- energy.i.elec(idx_industry_EXIO)  # Need just the sum of all
# energy.therm <- TFEI.tot[cty_idx[exio.sect.idx]] - energy.elec - sum(energy.trp)
# Approach 2. Ignore total elec from EXIO and just scale total with sc
# With an assumption that sc is same for dfei and tfei
energy.nontrp <- TFEI.tot[cty_idx[exio.sect.idx]] - sum(energy.trp)
energy.elec <- energy.nontrp * sc[cty_idx[exio.sect.idx]]
energy.therm <- energy.nontrp * (1-sc[cty_idx[exio.sect.idx]])
industry_trp_energy <- c(energy.therm, energy.elec, energy.trp) # Total indirect energy/cap by decile
# not_conv_idx has 1 where the RAS did not converge.
# industry_trp_energy <- industry_trp_energy[not_conv_idx!=1,]
names(industry_trp_energy) <- c("Industry.themal", "Industry.elec", EX_catnames[idx_trnsprt_EXIO])
return(industry_trp_energy)
}
a.ex2 <- sapply(c(1:200), function(x) {
DeriveConsumptionEnergyShares.ex("IN", x, type='final')})
intensity.summary2 <- data.frame(EXIO=t(EX_catnames), t(a.ex2), TFEI=TFEI.tot[IND_idx_ex],
DFEI=colSums(f_energy_int)[IND_idx_ex],
TPEI=colSums(indirect_pE_int.elec.prirow)[IND_idx_ex],
DPEI=colSums(p_energy_int.prirow)[IND_idx_ex], TEI=colSums(indirect_El_int)[IND_idx_ex],
DEI=colSums(elec_int)[IND_idx_ex])
intensity.summary2[which(intensity.summary2$TFEI==0), c(2:10)] <- 0
view(intensity.summary2)
carrier.name.fin <- gsub("Energy Carrier Use ", "", as.character(material.name[energy_carrier_use_idx]))
carrier.name.pr <- gsub("Nature Inputs: ", "", as.character(material.name[nature_input_idx]))
primary.in.use <- carrier.name.fin %in% carrier.name.pr
primary.in.use[1:2] <- TRUE # Biomass
carrier.name.fin[primary.in.use]
# Different sections of energy extension
tot.priE.sect <- materials[nature_input_idx,]  # The energy extension has not intensities but total consumptions.
tot.useE.sect <- materials[energy_carrier_use_idx,]
tot.supplE.sect <- materials[energy_carrier_supply_idx,]
tot.fdE.sect <- fd_materials[energy_carrier_use_idx, -seq(7, 336, 7)] # Excluding exports
tot.fdE.elec <- fd_materials[elec_use_idx,]
tot.useE.gasol <- materials[gasol_use_idx,]
tot.useE.elec <- materials[elec_use_idx,]
tot.supplE.elec <- materials[elec_supply_idx,]
energy_sector_idx_ex  <- c(64:85, 91:95, 128:146, 148, 176:182)    # Column index for energy sectors (excluding pulp and extraction sectors)
fossil.elec.idx.ex    <- c(128, 129, 133)    # Column index for energy sectors (excluding pulp and extraction sectors)
elec.idx.ex           <- 128:141    # Column index for electricity sectors
renew.elec.idx.ex     <- c(131:132, 135:138)    # Column index for renewable electricity sectors
nonrenew.elec.idx.ex  <- setdiff(elec.idx.ex, renew.elec.idx.ex)
energy.carrier.idx.ex <- c(20:32, 64:85, 91:95, 128:146, 148, 176:182)    # Column index for energy sectors (excluding pulp and extraction sectors)
captive_sector_idx_ex <- c(108, 36, 104, 90, 28, 62, 101, 50, 88, 89, 55)    # Column index for major captive generation sectors (Just for India for now)
captive_sector_names  <- EX_catnames[captive_sector_idx_ex]
# Aluminum1/2, steel, chemicals, petroleum(crude oil), paper, cement, sugar, fertilizer1/2, textiles
### Indexing energy carriers (from "materials" matrix)
nature_input_idx            <- 1:19   # number of rows for E-carrier use after removing the row headers
emission_energy_carrier_idx <- 20:70   # number of rows for E-carrier use after removing the row headers
energy_carrier_supply_idx   <- 71:139   # number of rows for E-carrier use after removing the row headers
energy_carrier_use_idx      <- 140:208   # number of rows for E-carrier use after removing the row headers
elec_use_idx                <- 184:195   # number of rows for E-carrier use after removing the row headers
steam_use_idx               <- 201        # Column index for steam/hot water
renew_elec_use_idx          <- c(187, 188, 191:194)   # number of rows for renewable E-carrier use after removing the row headers
nonrenew_elec_use_idx       <- setdiff(elec_use_idx, renew_elec_use_idx)
gasol_use_idx               <- c(160, 161, 181)   # number of rows for E-carrier use after removing the row headers
elec_supply_idx             <- 115:126   # number of rows for E-carrier use after removing the row headers
captive_input_idx           <- c(4, 5, 26, 27, 12, 2)  # Coal, diesel, natural gas, biomass (bagass) index in energy_carrier_use block
# energy_pri_carrier_use_idx <- c(140:154, 187:188, 191:194)   # number of rows for E-carrier use after removing the row headers
# energy_sec_carrier_use_idx <- energy_carrier_use_idx[!(energy_carrier_use_idx %in% energy_pri_carrier_use_idx)]
p_energy_int.prirow <- as.matrix(tot.useE.sect.pri) %*% diag(y)   # Derive energy intensities by dividing by total demand per sector TJ/M.EUR = MJ/EUR
tot.useE.sect.pri <- tot.useE.sect # This is not just for EXIO electricity sectors but all sectors with primary inputs
tot.useE.sect.pri[-which(primary.in.use), ] <- 0 # selecting only primary carrier rows from Use block
p_energy_int.prirow <- as.matrix(tot.useE.sect.pri) %*% diag(y)   # Derive energy intensities by dividing by total demand per sector TJ/M.EUR = MJ/EUR
indirect_pE_int.elec.prirow <- eigenMapMatMult(p_energy_int.prirow, as.matrix(L_inverse)) # faster
# example : eigenMapMatMult(X, Y)
library(Rcpp)
sourceCpp("matmult_test.cpp")
indirect_pE_int.elec.prirow <- eigenMapMatMult(p_energy_int.prirow, as.matrix(L_inverse)) # faster
balance.IEA <- read_excel("H:/MyDocuments/Analysis/Final energy/Energy extension IEA/Energy balance - IND-BRA-ZAF 2008 (TJ) - wide.xls", skip=6, col_names=FALSE, col_types="numeric") %>% select(-1, -2, -3) %>% slice(1:95)
balance.world <- read_excel("H:/MyDocuments/Analysis/Final energy/Energy extension IEA/Energy balance - World 2008 (TJ) - wide.xls", skip=6, col_names=FALSE, col_types="numeric") %>%
select(-1, -2, -3) %>% select(1:67) %>% slice(1:95)
names.prod <- read_excel("H:/MyDocuments/Analysis/Final energy/Energy extension IEA/Energy balance - World 2008 (TJ) - wide.xls", range="D4:BR4", col_names=FALSE)
names.flow <- read_excel("H:/MyDocuments/Analysis/Final energy/Energy extension IEA/Energy balance - World 2008 (TJ) - wide.xls", range="B7:B101", col_names=FALSE)
# IEA limits size for the download. So need to concatenate these.
balance.IEA <- cbind(balance.world, balance.IEA)
balance <- list()
for (i in 1:4) {
idx <- 1:67+(i-1)*67
b <- data.frame(balance.IEA[,idx])
names(b) <- make.names(names.prod)
b <- b %>% mutate(#coal=rowSums(.[c(1:13, 61:62)], na.rm=T),
#coalgas=rowSums(.[c(14:17, 60)], na.rm=T),
gasoline=rowSums(.[,c(21,36,63)], na.rm=T),
coal=rowSums(.[c(1:17, 60:62)], na.rm=T),
bio.waste=rowSums(.[c(18:25, 66:67)], na.rm=T),
oil=rowSums(.[c(27:32)], na.rm=T),  # incl. NGL
oil.prod=rowSums(.[c(33:46, 63:65)], na.rm=T),
ng=Natural.gas, # 26
elec=Electricity, # 56
heat=rowSums(.[,c(47,57)], na.rm=T),
renewable=rowSums(.[,c(49:55)], na.rm=T), # 55 (Other.sources) a bit tricky
nuclear=Nuclear # 48
) %>%
mutate(total = rowSums(select(.,coal:nuclear)), diff=total-Total) %>% select(total, Total, diff, everything())
row.names(b) <- make.names(names.flow$X__1)
balance[[i]] <- b
}
names(balance) <- c("World", "BRA", "IND", "ZAF")
balance$Oth <- balance$World - balance$BRA - balance$IND - balance$ZAF
# Get total and shares for final carrier categories
# Individually for the three countries. And global average for for other countries.
dfe <- function(x) {
df.e <- x %>% filter(row.names(.)=="Total.final.consumption") %>% select(coal:nuclear) %>% select(-oil, -nuclear, -heat)
sh.e <- df.e / sum(df.e)
return(list(TJ=df.e, Share=sh.e))
}
DFE <- lapply(balance, dfe)
# DFE$Oth$TJ <- DFE$World$TJ - DFE$BRA$TJ - DFE$IND$TJ - DFE$ZAF$TJ
# DFE$Oth$Share <- DFE$Oth$TJ / sum(DFE$Oth$TJ)
# Total DPE
dpe <- function(x) {
dp.e <- sum(x %>% filter(row.names(.) %in% c("Total.primary.energy.supply" ,"Transfers", "Statistical.differences"))  %>%
select(coal:nuclear))
return(dp.e)
}
DPE <- lapply(balance, dpe)
# DPE$Oth <- DPE$World - DPE$BRA - DPE$IND - DPE$ZAF
DFE$BRA$TJ$elec / DPE$BRA
DFE$IND$TJ$elec / DPE$IND
DFE$ZAF$TJ$elec / DPE$ZAF
balance$BRA %>% filter(row.names(.)=="Total.final.consumption") %>% select(gasoline) / DPE$BRA
balance$IND %>% filter(row.names(.)=="Total.final.consumption") %>% select(gasoline) / DPE$IND
balance$ZAF %>% filter(row.names(.)=="Total.final.consumption") %>% select(gasoline) / DPE$ZAF
# Derive TFEI
# sc <- rep(sum(DFE.Oth)/DPE.Oth, 9600); sc[BRA_idx_ex] <- sum(DFE.BRA)/DPE.BRA; sc[IND_idx_ex] <- sum(DFE.IND)/DPE.IND; sc[ZAF_idx_ex] <- sum(DFE.ZAF)/DPE.ZAF
# TFEI.tot    <- colSums(indirect_pE_int.elec.prirow) * sc
# sc <- rep(sum(DFE$Oth$Share %>% select(coal, bio.waste)), 9600); sc[BRA_idx_ex] <- sum(DFE$BRA$Share %>% select(coal, bio.waste)); sc[IND_idx_ex] <- sum(DFE$IND$Share %>% select(coal, bio.waste)); sc[ZAF_idx_ex] <- sum(DFE$ZAF$Share %>% select(coal, bio.waste))
# TFEI.solid  <- TFEI.tot * sc
# sc <- rep(DFE$Oth$Share$oil.prod, 9600); sc[BRA_idx_ex] <- DFE$BRA$Share$oil.prod ; sc[IND_idx_ex] <- DFE$IND$Share$oil.prod; sc[ZAF_idx_ex] <- DFE$ZAF$Share$oil.prod
# TFEI.liquid <- TFEI.tot * sc
# sc <- rep(DFE$Oth$Share$ng, 9600); sc[BRA_idx_ex] <- DFE$BRA$Share$ng ; sc[IND_idx_ex] <- DFE$IND$Share$ng; sc[ZAF_idx_ex] <- DFE$ZAF$Share$ng
# TFEI.gas    <- TFEI.tot * sc
# sc <- rep(DFE$Oth$Share$elec, 9600); sc[BRA_idx_ex] <- DFE$BRA$Share$elec ; sc[IND_idx_ex] <- DFE$IND$Share$elec; sc[ZAF_idx_ex] <- DFE$ZAF$Share$elec
# TFEI.elec   <- TFEI.tot * sc
# sc <- rep(DFE$Oth$Share$renewable, 9600); sc[BRA_idx_ex] <- DFE$BRA$Share$renewable ; sc[IND_idx_ex] <- DFE$IND$Share$renewable; sc[ZAF_idx_ex] <- DFE$ZAF$Share$renewable
# TFEI.renewable   <- TFEI.tot * sc
#
# all.equal(TFEI.tot, TFEI.solid+TFEI.liquid+TFEI.gas+TFEI.elec+TFEI.renewable)
# Electricity conversion efficiency
elec.eff <- function(x) {
elec <- x %>% filter(row.names(.)=="Main.activity.producer.electricity.plants..transf..") %>%
select(-c(gasoline:nuclear), -Memo..Renewables, -total, -Total, -diff)
elec.eff <- -elec$Electricity / sum(elec[which(elec<0)], na.rm=TRUE)
return(elec.eff)
}
elec.conv <- lapply(balance, elec.eff)
# Reverse the list structure
fun <-  function(ll) {
nms <- unique(unlist(lapply(ll, function(X) names(X))))
ll <- lapply(ll, function(X) setNames(X[nms], nms))
ll <- apply(do.call(rbind, ll), 2, as.list)
lapply(ll, function(X) X[!sapply(X, is.null)])
}
sum.list <- fun(list(balance=balance, DPE=DPE, DFE=DFE, elec.conv=elec.conv))
# Primary energy estimate from IEA final energy for main industries
industry.IEA <- c("Iron.and.steel", "Chemical.and.petrochemical", "Non.ferrous.metals", "Non.metallic.minerals", "Transport.equipment", "Machinery", "Mining.and.quarrying",
"Food.and.tobacco", "Paper..pulp.and.print", "Wood.and.wood.products", "Construction", "Textile.and.leather", "Non.specified..industry.",
"World.aviation.bunkers", "Domestic.aviation", "Road", "Rail", "Pipeline.transport", "World.marine.bunkers", "Domestic.navigation", "Non.specified..transport.",
"Commercial.and.public.services", "Agriculture.forestry", "Fishing")
# Derive p-to-f
pri.e.industry <- function(x) {
e.ind <- x$balance %>% filter(row.names(.) %in% industry.IEA)
e <- e.ind %>% select(-c(gasoline:nuclear), -Memo..Renewables, -total, -Total, -diff) %>%
mutate(primary.tot.est=Electricity/x$elec.conv+rowSums(., na.rm=TRUE)-Electricity)
x$p.to.f <- data.frame(IEA.sect=industry.IEA, primary.tot.est=e$primary.tot.est, final.tot=e.ind$total, elec.tot=e$Electricity) %>%
mutate(pf.ratio=final.tot/primary.tot.est, elec.share=elec.tot/final.tot) %>%
mutate_cond(is.nan(pf.ratio) | is.na(pf.ratio), pf.ratio=0) %>%
mutate_cond(is.nan(elec.share) | is.na(elec.share), elec.share=0)
return(x)
}
sum.list <- lapply(sum.list, pri.e.industry)
sum.list <- lapply(sum.list, function(x)
{x$avg.sc <- sum(x$DFE$TJ)/x$DPE
x$avg.elec.share <- as.numeric(x$balance %>% filter(row.names(.)=="Non.specified..industry.") %>% # This will be used mainly for waste/recycling industry.
mutate(avg.elec.share=Electricity/Total) %>% select(avg.elec.share))
return(x)}) # Create avg.sc for each country
# p-f scaler by EXiO sector by country
map.EXIO.IEA <- read.xlsx("H:/MyDocuments/Analysis/Final energy/Mapping/ISIC3-ISIC4.xlsx", sheet=2) %>% select(-2) #%>% select(EXIO, IEA.sect2) %>% rename(IEA.sect=IEA.sect2)
scaler.P.F <- lapply(sum.list, function(x) {map.EXIO.IEA %>% left_join(x$p.to.f) %>%
mutate_cond(IEA.sect=="Energy", pf.ratio=0, elec.share=0) %>%   # Energy sectors (extraction, refinery, elec) assuming energy sector own-use=0 (i.e. we don't want this in our TFEI)
mutate_cond(IEA.sect=="Other", pf.ratio=x$avg.sc, elec.share=x$avg.elec.share) %>% # Mainly waste management and recycle
select(EXIO, pf.ratio, elec.share)
})
# Construct 9600 vector for all EXIO sectors
sc <- rep(scaler.P.F$Oth$pf.ratio, 48); sc[BRA_idx_ex] <- scaler.P.F$BRA$pf.ratio; sc[IND_idx_ex] <- scaler.P.F$IND$pf.ratio; sc[ZAF_idx_ex] <- scaler.P.F$ZAF$pf.ratio
TFEI.tot <- colSums(indirect_pE_int.elec.prirow) * sc # MJ/EUR
# DFEI.tot <- colSums(p_energy_int.prirow) * sc # This scaling is not making much sense. It is so small for non-energy industries.
# Sanity check. (IEA TFE 2007 = 350675 PJ) - This doesn't include own use and any indirect FE from energy industry.
TF <- (TFEI.tot * rowSums(final_demand))
TP <- (colSums(indirect_pE_int.elec.prirow) * rowSums(final_demand))
TP <- (colSums(indirect_E_int) * rowSums(final_demand))
fd.idx <- as.vector(sapply(seq(0,327,7), function(x) x+c(1:3), simplify = "array"))
TFE.global <- sum(TF) + sum(fd_materials[energy_carrier_use_idx, fd.idx]) # 336229 PJ
TFE.BRA <- sum(TF[BRA_idx_ex]) + sum(fd_materials[energy_carrier_use_idx, BRA_idx_fd[1:3]]) # 7413 PJ (7861 PJ IEA)
TFE.IND <- sum(TF[IND_idx_ex]) + sum(fd_materials[energy_carrier_use_idx, IND_idx_fd[1:3]]) # 20462 PJ (16771 PJ IEA)
TFE.ZAF <- sum(TF[ZAF_idx_ex]) + sum(fd_materials[energy_carrier_use_idx, ZAF_idx_fd[1:3]]) # 2690 PJ (2909 PJ IEA)
# Scaling TFEI to get TFEI.elec
sc <- rep(scaler.P.F$Oth$elec.share, 48); sc[BRA_idx_ex] <- scaler.P.F$BRA$elec.share; sc[IND_idx_ex] <- scaler.P.F$IND$elec.share; sc[ZAF_idx_ex] <- scaler.P.F$ZAF$elec.share
# a.ex <- sapply(c(1:200), function(x) {
#   DeriveConsumptionEnergyShares.ex("IN", x, type='final')})
a.ex2 <- sapply(c(1:200), function(x) {
DeriveConsumptionEnergyShares.ex("IN", x, type='final')})
DeriveConsumptionEnergyShares.ex <- function (country = "IN", exio.sect.idx, type='final',
tfei=TFEI.tot, tpei=indirect_pE_int.elec.prirow, elec.share=sc) {
industry_trp_energy <- vector()
idx_trnsprt_EXIO <- 157:163
idx_industry_EXIO <- setdiff(1:200, idx_trnsprt_EXIO)
print(exio.sect.idx)
cty_place <- which(exio_ctys==country)
cty_idx <- seq(200*(cty_place-1)+1, 200*cty_place)  # 200 EXIO commodities per country
# Unit FD vector for the sector i (=exio.sect.idx)
y.unit <- matrix(unit.vector(cty_idx[exio.sect.idx], 9600), ncol=1)
# if(type=='final') {
#   int.e <- totuse_int   # We still need to add direct final energy intensity after this.
# }
# else if(type=='primary') {
#   int.e <- p_energy_int.prirow
# }
# Carve out only the transport sectors
idx.trp <- as.vector(sapply(seq(0,9400,200), function(x) x+idx_trnsprt_EXIO, simplify = "array"))
direct.int.trp <- totuse_int # totuse_int: Globally defined
direct.int.trp[, -idx.trp] <- 0
# Derive total demand: L*y
ind.x.sect <- eigenMapMatMult(as.matrix(L_inverse), y.unit)   # 9600x1  the column of L_inv
### Total transport energy
e.trp <- eigenMapMatMult(direct.int.trp, diag(as.vector(ind.x.sect)))   # n_carrierx9600
energy.i <- function(i) {
return(sum(e.trp[, i+seq(0, 9400, 200)]))
}
energy.trp <- sapply(idx_trnsprt_EXIO, energy.i) # Need to sum for each mode
# Assumption: Total transport energy is 100% transport energy
# Otherwise, some exceptionally high DFEI transport sector (e.g. inland water in IND) gives (-) intensity for tfei.ind.
if (exio.sect.idx %in% idx_trnsprt_EXIO) {
energy.trp <- energy.trp / sum(energy.trp) * TFEI.tot[cty_idx[exio.sect.idx]]
}
### Total non-transport energy
# Approach 1. Get total elec from EXIO and subtract it (& transport E) from TFEI.tot
# e.elec <- eigenMapMatMult(elec_int, diag(as.vector(ind.x.sect)))   # elec_int: Globally defined
#
# energy.i.elec <- function(i) {
#   idx <- as.vector(sapply(seq(0,9400,200), function(x) x+i, simplify = "array"))
#   return(sum(e.elec[, idx]))
# }
# energy.elec <- energy.i.elec(idx_industry_EXIO)  # Need just the sum of all
# energy.therm <- TFEI.tot[cty_idx[exio.sect.idx]] - energy.elec - sum(energy.trp)
# Approach 2. Ignore total elec from EXIO and just scale total with sc
# With an assumption that sc is same for dfei and tfei
energy.nontrp <- TFEI.tot[cty_idx[exio.sect.idx]] - sum(energy.trp)
energy.elec <- energy.nontrp * sc[cty_idx[exio.sect.idx]]
energy.therm <- energy.nontrp * (1-sc[cty_idx[exio.sect.idx]])
industry_trp_energy <- c(energy.therm, energy.elec, energy.trp) # Total indirect energy/cap by decile
# not_conv_idx has 1 where the RAS did not converge.
# industry_trp_energy <- industry_trp_energy[not_conv_idx!=1,]
names(industry_trp_energy) <- c("Industry.themal", "Industry.elec", EX_catnames[idx_trnsprt_EXIO])
return(industry_trp_energy)
}
a.ex2 <- sapply(c(1:200), function(x) {
DeriveConsumptionEnergyShares.ex("IN", x, type='final')})
intensity.summary2 <- data.frame(EXIO=t(EX_catnames), t(a.ex2), TFEI=TFEI.tot[IND_idx_ex],
DFEI=colSums(f_energy_int)[IND_idx_ex],
TPEI=colSums(indirect_pE_int.elec.prirow)[IND_idx_ex],
DPEI=colSums(p_energy_int.prirow)[IND_idx_ex], TEI=colSums(indirect_El_int)[IND_idx_ex],
DEI=colSums(elec_int)[IND_idx_ex])
intensity.summary2[which(intensity.summary2$TFEI==0), c(2:10)] <- 0
view(intensity.summary2)
TFEI.exio <- data.frame(EXIO=t(EX_catnames), t(a.ex2), TFEI=TFEI.tot)
view(TFEI.exio)
dim(TFEI.exio)
view(TFEI.exio)
rep(exio_ctys, 2)
?rep
rep.int(exio_ctys, 2)
rep(exio_ctys, each=2)
TFEI.exio <- data.frame(Region=rep(exio_ctys, each=200), EXIO=t(EX_catnames), t(a.ex2), TFEI=TFEI.tot)
view(TFEI.exio)
getwd()
save(TFEI.exio, file="H:/MyDocuments/IO work/DLE_scripts/Saved tables/TFEI.exio.Rda")
head(TFEI.exio)
names(TFEI.exio) <- c("Region", "EXIO", "ind.therm", "ind.elec", "rail", "road", "pipeline", "sea", "inland", "air", "other", "total")
save(TFEI.exio, file="H:/MyDocuments/IO work/DLE_scripts/Saved tables/TFEI.exio.Rda")
head(TFEI.exio)
n_draw
n_draw=10
dim(indirect_fE_int
)
class(indirect_fE_int)
class(TFEI.tot)
class(TFEI.tot)=="numeric"
matrix((TFEI.tot)
, nrow=1)
dim(matrix((TFEI.tot)
, nrow=1))
list[IND_f.intensity, IND_f.alloc, NC_f.IND, IND_f.FD_adj] <- DeriveIntensities('IND', 'final', TFEI.exio$ind.therm)
list[IND_f.ind.therm, IND_f.alloc, NC_f.IND, IND_f.FD_adj] <- DeriveIntensities('IND', 'final', TFEI.exio$ind.therm)
list[IND_f.ind.elec, IND_f.alloc, NC_f.IND, IND_f.FD_adj] <- DeriveIntensities('IND', 'final', TFEI.exio$ind.elec)
list[IND_f.rail, IND_f.alloc, NC_f.IND, IND_f.FD_adj] <- DeriveIntensities('IND', 'final', TFEI.exio$rail)
list[IND_f.road, IND_f.alloc, NC_f.IND, IND_f.FD_adj] <- DeriveIntensities('IND', 'final', TFEI.exio$road)
list[IND_f.sea, IND_f.alloc, NC_f.IND, IND_f.FD_adj] <- DeriveIntensities('IND', 'final', TFEI.exio$sea)
list[IND_f.inland, IND_f.alloc, NC_f.IND, IND_f.FD_adj] <- DeriveIntensities('IND', 'final', TFEI.exio$inland)
list[IND_f.air, IND_f.alloc, NC_f.IND, IND_f.FD_adj] <- DeriveIntensities('IND', 'final', TFEI.exio$air)
list[IND_f.total, IND_f.alloc, NC_f.IND, IND_f.FD_adj] <- DeriveIntensities('IND', 'final', TFEI.exio$total)
dim(IND_f.total)
colMeans(IND_f.total)
list[IND_f.pipeline, IND_f.alloc, NC_f.IND, IND_f.FD_adj] <- DeriveIntensities('IND', 'final', TFEI.exio$pipeline)
list[IND_f.other.trp, IND_f.alloc, NC_f.IND, IND_f.FD_adj] <- DeriveIntensities('IND', 'final', TFEI.exio$other.trp)
list[IND_f.other.trp, IND_f.alloc, NC_f.IND, IND_f.FD_adj] <- DeriveIntensities('IND', 'final', TFEI.exio$other)
a <- data.frame(ICP_catnames, colMeans(IND_f.ind.therm), colMeans(IND_f.ind.elec), colMeans(IND_f.rail),
colMeans(IND_f.road), colMeans(IND_f.pipeline), colMeans(IND_f.sea), colMeans(IND_f.inland),
colMeans(IND_f.air), colMeans(IND_f.other.trp), colMeans(IND_f.total))
names(a) <- c("ICP", "ind.therm", "ind.elec", "rail", "road", "pipeline", "sea", "inland", "air", "other", "total")
view(a)
tfei.call <- function(x, country) {
list[tfei.part, IND_f.alloc, NC_f.IND, IND_f.FD_adj] <- DeriveIntensities(country, 'final', x)
int <- colMeans(tfei.part)
return(int)
}
a <- apply(TFEI.exio[, -c(1,2)], 2, tfei.call)
a <- apply(TFEI.exio[, -c(1,2)], 2, tfei.call, 'IND')
class(a)
a
dim(a)
dim(TFEI.exio)
view(a)
a <- data.frame(ICP_catnames, a)
names(a) <- c("ICP", "ind.therm", "ind.elec", "rail", "road", "pipeline", "sea", "inland", "air", "other", "total")
view(a)
TFEI.IND.icp <- a
save(TFEI.IND.icp, file="H:/MyDocuments/IO work/DLE_scripts/Saved tables/TFEI.IND.icp.Rda")
TFEI.BRA.icp <- apply(TFEI.exio[, -c(1,2)], 2, tfei.call, 'BRA')
TFEI.BRA.icp <- data.frame(ICP_catnames, TFEI.BRA.icp)
names(TFEI.BRA.icp) <- c("ICP", "ind.therm", "ind.elec", "rail", "road", "pipeline", "sea", "inland", "air", "other", "total")
load(file="H:/MyDocuments/IO work/DLE_scripts/Saved tables/BRA_FD_harmonized.Rda")
load(file="H:/MyDocuments/IO work/DLE_scripts/Saved tables/ZAF_AllHHConsump.Rda")
scaler_BRA <- sum(BRA_FD_ICP_usd2007[,1]) / sum(BRA_fd_exio_pp_EX)
load(file="H:/MyDocuments/IO work/DLE_scripts/Saved tables/ZAF_FD_ICP_usd2007.Rda")
load(file="H:/MyDocuments/IO work/DLE_scripts/Saved tables/BRA_FD_ICP_usd2007.Rda")
BRA_fd_exio_pp_EX <- get_purch_price(BRA_fd_exio, "BR")
scaler_BRA <- sum(BRA_FD_ICP_usd2007[,1]) / sum(BRA_fd_exio_pp_EX)
init_FD_BRA <- BRA_FD_ICP_usd2007[,1] / scaler_BRA
ZAF_fd_exio_pp <- get_purch_price(ZAF_fd_exio, "ZA")
scaler_ZAF <- sum(ZAF_FD_ICP_usd2007[,1]) / sum(ZAF_fd_exio_pp)
init_FD_ZAF <- ZAF_FD_ICP_usd2007[,1] / scaler_ZAF
load(file="H:/MyDocuments/IO work/DLE_scripts/Saved tables/ZAF_AllHHConsump.Rda")
ZAF_fd_exio_pp <- get_purch_price(ZAF_fd_exio, "ZA")
TFEI.BRA.icp <- apply(TFEI.exio[, -c(1,2)], 2, tfei.call, 'BRA')
TFEI.BRA.icp <- data.frame(ICP_catnames, TFEI.BRA.icp)
names(TFEI.BRA.icp) <- c("ICP", "ind.therm", "ind.elec", "rail", "road", "pipeline", "sea", "inland", "air", "other", "total")
TFEI.ZAF.icp <- apply(TFEI.exio[, -c(1,2)], 2, tfei.call, 'ZAF')
TFEI.ZAF.icp <- data.frame(ICP_catnames, TFEI.ZAF.icp)
names(TFEI.ZAF.icp) <- c("ICP", "ind.therm", "ind.elec", "rail", "road", "pipeline", "sea", "inland", "air", "other", "total")
save(TFEI.BRA.icp, file="H:/MyDocuments/IO work/DLE_scripts/Saved tables/TFEI.BRA.icp.Rda")
source('H:/MyDocuments/IO work/DLE_scripts/Valuation.R', echo=TRUE)
TFEI.ZAF.icp <- apply(TFEI.exio[, -c(1,2)], 2, tfei.call, 'ZAF')
save(TFEI.ZAF.icp, file="H:/MyDocuments/IO work/DLE_scripts/Saved tables/TFEI.ZAF.icp.Rda")
